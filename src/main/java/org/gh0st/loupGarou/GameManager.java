package org.gh0st.loupGarou;

import org.bukkit.*;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;
import java.util.*;

public class GameManager {

    private final LoupGarouPlugin plugin;
    private final Map<UUID, PlayerRole> players = new HashMap<>();
    private final Map<UUID, UUID> votes = new HashMap<>();
    private final Map<UUID, Boolean> witchHealUsed = new HashMap<>();
    private final Map<UUID, Boolean> witchPoisonUsed = new HashMap<>();
    private final Map<UUID, Boolean> guardSelfProtected = new HashMap<>();
    private final Map<UUID, Boolean> seerUsedPower = new HashMap<>();
    private final Map<UUID, Boolean> guardUsedPower = new HashMap<>();
    private GameState currentState = GameState.WAITING;
    private BukkitTask gameTask;
    private int dayNumber = 0;
    private UUID protectedPlayer;
    private UUID witchHealTarget;
    private UUID witchPoisonTarget;
    private long gameStartTime = 0; // ‚Üê AJOUT pour bStats

    public GameManager(LoupGarouPlugin plugin) {
        this.plugin = plugin;
    }

    public enum GameState {
        WAITING("¬ß7En attente"),
        STARTING("¬ßeCommencement"),
        NIGHT("¬ß1üåô Nuit"),
        DAY("¬ße‚òÄÔ∏è Jour"),
        VOTE("¬ßcüó≥Ô∏è Vote"),
        FINISHED("¬ßaTermin√©");

        private final String displayName;

        GameState(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    public boolean startGame() {
        if (currentState != GameState.WAITING) {
            broadcastMessage("¬ßc‚ùå Une partie est d√©j√† en cours !");
            return false;
        }

        Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
        if (onlinePlayers.size() < plugin.getConfigManager().getMinPlayers()) {
            broadcastMessage(Messages.format(Messages.NOT_ENOUGH_PLAYERS, plugin.getConfigManager().getMinPlayers()));
            return false;
        }

        // V√©rifier que les joueurs sont dans la bonne r√©gion/monde
        WorldGuardIntegration wg = plugin.getWorldGuardIntegration();
        if (plugin.getConfigManager().isWorldGuardEnabled() && wg.isWorldGuardAvailable()) {
            List<Player> invalidPlayers = new ArrayList<>();

            for (Player player : onlinePlayers) {
                if (!wg.isPlayerInCorrectWorld(player)) {
                    invalidPlayers.add(player);
                    player.sendMessage(plugin.getConfigManager().getMessagePrefix() + " " +
                            plugin.getConfigManager().getWrongWorldMessage());
                } else if (!wg.canPlayerPlay(player)) {
                    invalidPlayers.add(player);
                    player.sendMessage(plugin.getConfigManager().getMessagePrefix() + " " +
                            plugin.getConfigManager().getNotInRegionMessage());
                }
            }

            if (!invalidPlayers.isEmpty()) {
                broadcastMessage("¬ßc‚ùå Certains joueurs ne sont pas dans la zone de jeu !");
                broadcastMessage("¬ßeüí° Tous les joueurs doivent √™tre dans le monde '" +
                        plugin.getConfigManager().getWorldGuardWorld() +
                        "' et dans la r√©gion '" +
                        plugin.getConfigManager().getRegionName() + "'");
                return false;
            }
        }

        currentState = GameState.STARTING;
        gameStartTime = System.currentTimeMillis(); // ‚Üê AJOUT pour bStats

        // Reset des donn√©es
        resetGameData();

        // Pr√©paration de la partie
        assignRoles();
        sendRoleMessages();
        teleportPlayersToGame();

        // Annonces
        broadcastMessage(Messages.GAME_STARTING);
        broadcastMessage(Messages.ROLES_DISTRIBUTING);
        SoundManager.playGameStart();

        // D√©marrer la premi√®re nuit apr√®s 10 secondes
        Bukkit.getScheduler().runTaskLater(plugin, () -> startNight(), 200L);

        // Mettre √† jour le scoreboard
        plugin.getScoreboardManager().updateScoreboard();

        return true;
    }

    private void resetGameData() {
        players.clear();
        votes.clear();
        witchHealUsed.clear();
        witchPoisonUsed.clear();
        guardSelfProtected.clear();
        seerUsedPower.clear();
        guardUsedPower.clear();
        dayNumber = 0;
        protectedPlayer = null;
        witchHealTarget = null;
        witchPoisonTarget = null;

        // Nettoyer les √©quipes du scoreboard
        plugin.getScoreboardManager().removeAllTeams();
    }

    private void assignRoles() {
        List<Player> playerList = new ArrayList<>(Bukkit.getOnlinePlayers());
        Collections.shuffle(playerList);

        int playerCount = playerList.size();
        int werewolfCount = Math.max(1, (int) (playerCount * plugin.getConfigManager().getWerewolfRatio()));

        int currentIndex = 0;

        // Attribution des loups-garous
        for (int i = 0; i < werewolfCount && currentIndex < playerList.size(); i++) {
            Player player = playerList.get(currentIndex++);
            players.put(player.getUniqueId(), PlayerRole.WEREWOLF);
            plugin.getScoreboardManager().addPlayerRole(player, PlayerRole.WEREWOLF);

            // ‚Üê AJOUT pour bStats
            if (plugin.getBStatsManager() != null) {
                plugin.getBStatsManager().recordRoleUsage(PlayerRole.WEREWOLF);
            }
        }

        // Attribution des r√¥les sp√©ciaux selon le nombre de joueurs
        if (playerCount >= plugin.getConfigManager().getSeerMinPlayers() && currentIndex < playerList.size()) {
            Player player = playerList.get(currentIndex++);
            players.put(player.getUniqueId(), PlayerRole.SEER);
            plugin.getScoreboardManager().addPlayerRole(player, PlayerRole.SEER);

            // ‚Üê AJOUT pour bStats
            if (plugin.getBStatsManager() != null) {
                plugin.getBStatsManager().recordRoleUsage(PlayerRole.SEER);
            }
        }

        if (playerCount >= plugin.getConfigManager().getGuardMinPlayers() && currentIndex < playerList.size()) {
            Player player = playerList.get(currentIndex++);
            players.put(player.getUniqueId(), PlayerRole.GUARD);
            plugin.getScoreboardManager().addPlayerRole(player, PlayerRole.GUARD);

            // ‚Üê AJOUT pour bStats
            if (plugin.getBStatsManager() != null) {
                plugin.getBStatsManager().recordRoleUsage(PlayerRole.GUARD);
            }
        }

        if (playerCount >= plugin.getConfigManager().getWitchMinPlayers() && currentIndex < playerList.size()) {
            Player player = playerList.get(currentIndex++);
            players.put(player.getUniqueId(), PlayerRole.WITCH);
            plugin.getScoreboardManager().addPlayerRole(player, PlayerRole.WITCH);

            // ‚Üê AJOUT pour bStats
            if (plugin.getBStatsManager() != null) {
                plugin.getBStatsManager().recordRoleUsage(PlayerRole.WITCH);
            }
        }

        // Le reste devient villageois
        while (currentIndex < playerList.size()) {
            Player player = playerList.get(currentIndex++);
            players.put(player.getUniqueId(), PlayerRole.VILLAGER);
            plugin.getScoreboardManager().addPlayerRole(player, PlayerRole.VILLAGER);

            // ‚Üê AJOUT pour bStats
            if (plugin.getBStatsManager() != null) {
                plugin.getBStatsManager().recordRoleUsage(PlayerRole.VILLAGER);
            }
        }
    }

    private void sendRoleMessages() {
        for (Player player : Bukkit.getOnlinePlayers()) {
            PlayerRole role = players.get(player.getUniqueId());
            if (role != null) {
                player.sendMessage("¬ß6" + "=".repeat(50));
                player.sendMessage(Utils.centerText("¬ß6¬ßlüé≠ VOTRE R√îLE üé≠", 50));
                player.sendMessage("¬ß6" + "=".repeat(50));
                player.sendMessage("");
                player.sendMessage("¬ßeüé≠ Vous √™tes : " + role.getDisplayName());
                player.sendMessage("");
                player.sendMessage("¬ßfüìñ Description :");
                player.sendMessage("¬ßf" + role.getDescription());
                player.sendMessage("");
                player.sendMessage("¬ß6" + "=".repeat(50));

                // Son et titre selon le r√¥le
                SoundManager.playRoleReveal(player, role);
                player.sendTitle(role.getDisplayName(), "¬ßfC'est votre r√¥le !", 20, 80, 20);
            }
        }
    }

    private void startNight() {
        dayNumber++;
        currentState = GameState.NIGHT;
        votes.clear();
        protectedPlayer = null;
        witchHealTarget = null;
        witchPoisonTarget = null;

        // Reset des pouvoirs utilis√©s cette nuit
        seerUsedPower.clear();
        guardUsedPower.clear();

        broadcastMessage(Messages.format(Messages.NIGHT_START, dayNumber));
        broadcastMessage(Messages.NIGHT_DESCRIPTION);

        SoundManager.playNightStart();

        // Effet de nuit SEULEMENT pour les joueurs dans la partie
        setTimeForPlayers(18000);

        // Instructions pour chaque r√¥le
        sendNightInstructions();

        // Timer pour la phase de nuit
        int nightDuration = plugin.getConfigManager().getNightDuration();
        broadcastMessage("¬ß9‚è∞ Phase de nuit : " + Utils.formatTime(nightDuration));

        gameTask = new BukkitRunnable() {
            @Override
            public void run() {
                processNightActions();
                startDay();
            }
        }.runTaskLater(plugin, nightDuration * 20L);

        plugin.getScoreboardManager().updateScoreboard();
    }

    private void sendNightInstructions() {
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (!isPlayerAlive(player)) continue;

            PlayerRole role = players.get(player.getUniqueId());
            if (role == null) continue;

            switch (role) {
                case WEREWOLF:
                    player.sendMessage("¬ßcüê∫ === PHASE DES LOUPS-GAROUS ===");
                    player.sendMessage("¬ßcüíÄ Choisissez votre victime : /lg tuer <joueur>");
                    showAliveVillagers(player);
                    break;

                case SEER:
                    player.sendMessage("¬ß5üîÆ === PHASE DE LA VOYANTE ===");
                    player.sendMessage("¬ß5üëÅÔ∏è D√©couvrez un r√¥le : /lg voir <joueur>");
                    showAlivePlayers(player);
                    break;

                case GUARD:
                    player.sendMessage("¬ßbüõ°Ô∏è === PHASE DU GARDE ===");
                    player.sendMessage("¬ßbüõ°Ô∏è Prot√©gez quelqu'un : /lg proteger <joueur>");
                    if (!hasGuardProtectedHimself(player)) {
                        player.sendMessage("¬ßbüí° Vous pouvez vous prot√©ger une fois par partie");
                    }
                    showAlivePlayers(player);
                    break;

                case WITCH:
                    player.sendMessage("¬ßdüß™ === PHASE DE LA SORCI√àRE ===");
                    if (!hasWitchUsedHealPotion(player)) {
                        player.sendMessage("¬ßdüíö Soigner : /lg soigner <joueur>");
                    }
                    if (!hasWitchUsedPoisonPotion(player)) {
                        player.sendMessage("¬ßd‚ò†Ô∏è Empoisonner : /lg empoisonner <joueur>");
                    }
                    showAlivePlayers(player);
                    break;

                case VILLAGER:
                    player.sendMessage("¬ßaüò¥ Vous dormez paisiblement...");
                    player.sendMessage("¬ß7üí≠ Observez le chat pour voir ce qui se passe...");
                    break;
            }
        }
    }

    private void processNightActions() {
        broadcastMessage("¬ß9üåÖ L'aube se l√®ve... D√©couvrons ce qui s'est pass√© cette nuit.");

        // Traiter les votes des loups-garous
        Map<UUID, Integer> killVotes = new HashMap<>();
        for (UUID voterId : votes.keySet()) {
            if (players.get(voterId) == PlayerRole.WEREWOLF) {
                UUID target = votes.get(voterId);
                killVotes.put(target, killVotes.getOrDefault(target, 0) + 1);
            }
        }

        // Trouver la victime principale
        UUID victim = null;
        int maxVotes = 0;
        for (Map.Entry<UUID, Integer> entry : killVotes.entrySet()) {
            if (entry.getValue() > maxVotes) {
                maxVotes = entry.getValue();
                victim = entry.getKey();
            }
        }

        // R√©soudre les actions de nuit
        boolean someoneProtected = false;
        boolean someoneHealed = false;

        if (victim != null) {
            Player victimPlayer = Bukkit.getPlayer(victim);
            if (victimPlayer != null && isPlayerAlive(victimPlayer)) {

                // V√©rifier la protection du garde
                boolean isProtected = victim.equals(protectedPlayer);

                // V√©rifier si la sorci√®re gu√©rit
                boolean isHealed = victim.equals(witchHealTarget);

                if (isProtected) {
                    someoneProtected = true;
                } else if (isHealed) {
                    someoneHealed = true;
                } else {
                    eliminatePlayer(victimPlayer, "d√©vor√© par les loups-garous");
                }
            }
        }

        // Traiter le poison de la sorci√®re
        if (witchPoisonTarget != null) {
            Player poisonedPlayer = Bukkit.getPlayer(witchPoisonTarget);
            if (poisonedPlayer != null && isPlayerAlive(poisonedPlayer)) {
                eliminatePlayer(poisonedPlayer, "empoisonn√© par la sorci√®re");
            }
        }

        // Messages informatifs
        if (someoneProtected) {
            broadcastMessage(Messages.PROTECTED_SOMEONE);
        }
        if (someoneHealed) {
            broadcastMessage(Messages.WITCH_SAVED);
        }
        if (victim == null && witchPoisonTarget == null) {
            broadcastMessage(Messages.QUIET_NIGHT);
        }
    }

    private void startDay() {
        currentState = GameState.DAY;
        votes.clear();

        broadcastMessage(Messages.format(Messages.DAY_START, dayNumber));
        broadcastMessage(Messages.DAY_DESCRIPTION);

        SoundManager.playDayStart();

        // Effet de jour SEULEMENT pour les joueurs dans la partie
        setTimeForPlayers(6000);

        // V√©rifier les conditions de victoire
        if (checkWinConditions()) {
            return;
        }

        showGameStatus();

        // Phase de discussion
        int dayDuration = plugin.getConfigManager().getDayDuration();
        broadcastMessage("¬ßeüí¨ Phase de discussion ! (" + Utils.formatTime(dayDuration) + ")");
        broadcastMessage("¬ßeüó£Ô∏è C'est le moment de d√©battre et de trouver les coupables !");

        gameTask = new BukkitRunnable() {
            @Override
            public void run() {
                startVotePhase();
            }
        }.runTaskLater(plugin, dayDuration * 20L);

        plugin.getScoreboardManager().updateScoreboard();
    }

    private void startVotePhase() {
        currentState = GameState.VOTE;
        votes.clear();

        broadcastMessage(Messages.VOTE_START);
        broadcastMessage(Messages.VOTE_DESCRIPTION);
        broadcastMessage("¬ßeüí° Utilisez : ¬ßf/vote <joueur> ¬ßepour voter");

        SoundManager.playVoteStart();
        showAlivePlayers();

        // Timer pour les votes
        int voteDuration = plugin.getConfigManager().getVoteDuration();
        broadcastMessage("¬ßc‚è∞ Vous avez " + Utils.formatTime(voteDuration) + " pour voter !");

        gameTask = new BukkitRunnable() {
            @Override
            public void run() {
                processVotes();
            }
        }.runTaskLater(plugin, voteDuration * 20L);

        plugin.getScoreboardManager().updateScoreboard();
    }

    private void processVotes() {
        Map<UUID, Integer> voteCount = new HashMap<>();
        Set<UUID> voters = new HashSet<>();

        // Compter les votes valides
        for (Map.Entry<UUID, UUID> vote : votes.entrySet()) {
            UUID voter = vote.getKey();
            UUID target = vote.getValue();

            Player voterPlayer = Bukkit.getPlayer(voter);
            Player targetPlayer = Bukkit.getPlayer(target);

            if (isPlayerAlive(voterPlayer) && isPlayerAlive(targetPlayer)) {
                voteCount.put(target, voteCount.getOrDefault(target, 0) + 1);
                voters.add(voter);
            }
        }

        broadcastMessage("¬ß6üìä === R√âSULTATS DES VOTES ===");

        if (voteCount.isEmpty()) {
            broadcastMessage("¬ß7üò¥ Aucun vote valide ! Personne n'est √©limin√©.");
        } else {
            // Afficher tous les r√©sultats
            List<Map.Entry<UUID, Integer>> sortedVotes = new ArrayList<>(voteCount.entrySet());
            sortedVotes.sort((a, b) -> b.getValue().compareTo(a.getValue()));

            for (Map.Entry<UUID, Integer> entry : sortedVotes) {
                Player target = Bukkit.getPlayer(entry.getKey());
                if (target != null) {
                    String plural = entry.getValue() > 1 ? "s" : "";
                    broadcastMessage("¬ße" + target.getName() + " : ¬ßf" + entry.getValue() + " vote" + plural);
                }
            }

            // √âliminer le joueur avec le plus de votes
            if (!sortedVotes.isEmpty()) {
                UUID mostVoted = sortedVotes.get(0).getKey();
                int maxVotes = sortedVotes.get(0).getValue();

                // V√©rifier s'il y a √©galit√©
                long playersWithMaxVotes = sortedVotes.stream()
                        .mapToInt(Map.Entry::getValue)
                        .filter(votes -> votes == maxVotes)
                        .count();

                if (playersWithMaxVotes > 1) {
                    broadcastMessage("¬ßc‚öñÔ∏è √âgalit√© ! Personne n'est √©limin√©.");
                } else {
                    Player eliminatedPlayer = Bukkit.getPlayer(mostVoted);
                    if (eliminatedPlayer != null) {
                        eliminatePlayer(eliminatedPlayer, "√©limin√© par vote du village");
                    }
                }
            }
        }

        broadcastMessage("¬ßeüë• Total des votants : " + voters.size() + "/" + getAlivePlayersCount());

        // V√©rifier les conditions de victoire
        if (!checkWinConditions()) {
            // Continuer avec une nouvelle nuit
            Bukkit.getScheduler().runTaskLater(plugin, this::startNight, 100L);
        }
    }

    private void eliminatePlayer(Player player, String reason) {
        PlayerRole role = players.get(player.getUniqueId());

        broadcastMessage("¬ßcüíÄ " + player.getName() + " a √©t√© " + reason + " !");
        broadcastMessage("¬ß6üé≠ " + player.getName() + " √©tait : " + (role != null ? role.getDisplayName() : "¬ßaVillageois"));

        // Effets visuels et sonores
        SoundManager.playElimination();
        player.setGameMode(GameMode.SPECTATOR);

        // Titre dramatique pour tous
        for (Player p : Bukkit.getOnlinePlayers()) {
            p.sendTitle("¬ßcüíÄ " + player.getName(), "¬ß6a √©t√© " + reason, 10, 60, 20);
        }

        // Statistiques
        plugin.getStatsManager().addDeath(player, reason);

        // Message priv√© au joueur √©limin√©
        player.sendMessage("¬ßcüíÄ Vous avez √©t√© √©limin√© ! Vous pouvez maintenant observer la partie.");
        player.sendMessage("¬ß7üí¨ Chattez avec les autres morts ou observez la suite...");
    }

    private boolean checkWinConditions() {
        int werewolves = 0;
        int villagers = 0;

        for (Player player : Bukkit.getOnlinePlayers()) {
            if (isPlayerAlive(player)) {
                PlayerRole role = players.get(player.getUniqueId());
                if (role != null) {
                    if (role == PlayerRole.WEREWOLF) {
                        werewolves++;
                    } else {
                        villagers++;
                    }
                }
            }
        }

        if (werewolves == 0) {
            endGame(
                    Messages.VILLAGE_VICTORY,
                    Messages.VILLAGE_VICTORY_REASON,
                    "village"
            );
            return true;
        } else if (werewolves >= villagers) {
            endGame(
                    Messages.WEREWOLF_VICTORY,
                    Messages.WEREWOLF_VICTORY_REASON,
                    "werewolves"
            );
            return true;
        }

        return false;
    }

    private void endGame(String title, String subtitle, String winningTeam) {
        currentState = GameState.FINISHED;

        if (gameTask != null) {
            gameTask.cancel();
        }

        // ‚Üê AJOUT pour bStats : Enregistrer les statistiques de la partie
        long gameDuration = (System.currentTimeMillis() - gameStartTime) / 1000; // en secondes
        int playerCount = players.size();

        if (plugin.getBStatsManager() != null) {
            plugin.getBStatsManager().recordGame(playerCount, gameDuration, winningTeam);
            plugin.getLogger().info("üìä Partie enregistr√©e dans bStats : " +
                    playerCount + " joueurs, " + (gameDuration / 60) + " minutes, gagnant: " + winningTeam);
        }

        // Annonce de fin
        broadcastMessage("¬ß6" + "=".repeat(60));
        broadcastMessage(Utils.centerText(title, 60));
        broadcastMessage(Utils.centerText(subtitle, 60));
        broadcastMessage("¬ß6" + "=".repeat(60));

        // R√©v√©ler tous les r√¥les
        broadcastMessage("");
        broadcastMessage("¬ßeüìã === R√âV√âLATION DE TOUS LES R√îLES ===");
        for (Player player : Bukkit.getOnlinePlayers()) {
            PlayerRole role = players.get(player.getUniqueId());
            if (role != null) {
                String status = isPlayerAlive(player) ? "¬ßa‚úÖ" : "¬ßcüíÄ";
                broadcastMessage(status + " ¬ßf" + player.getName() + " ¬ß7: " + role.getDisplayName());
            }
        }

        // Enregistrer les statistiques
        for (Player player : Bukkit.getOnlinePlayers()) {
            PlayerRole role = players.get(player.getUniqueId());
            if (role != null) {
                plugin.getStatsManager().addGamePlayed(player);

                // Ajouter victoire si dans l'√©quipe gagnante
                String playerTeam = role.getTeam();
                if (playerTeam.equals(winningTeam)) {
                    plugin.getStatsManager().addWin(player, role, winningTeam);
                }
            }
        }

        // Effets visuels pour tous
        SoundManager.playVictory();
        for (Player player : Bukkit.getOnlinePlayers()) {
            player.sendTitle(title, subtitle, 20, 100, 40);
            player.setGameMode(GameMode.SURVIVAL);
            player.resetPlayerTime();
        }

        broadcastMessage("");
        broadcastMessage("¬ßaüîÑ Nouvelle partie dans " + plugin.getConfigManager().getRestartDelay() + " secondes...");

        // Reset automatique
        if (plugin.getConfigManager().isAutoRestart()) {
            Bukkit.getScheduler().runTaskLater(plugin, this::resetGame, plugin.getConfigManager().getRestartDelay() * 20L);
        }
    }

    public void stopGame() {
        if (gameTask != null) {
            gameTask.cancel();
        }
        resetGame();
        broadcastMessage("¬ßc‚õî La partie a √©t√© arr√™t√©e par un administrateur.");
    }

    private void resetGame() {
        currentState = GameState.WAITING;
        resetGameData();

        // Remettre les joueurs en mode normal
        for (Player player : Bukkit.getOnlinePlayers()) {
            player.setGameMode(GameMode.SURVIVAL);
            player.resetPlayerTime();
        }

        broadcastMessage("¬ßaüîÑ Partie r√©initialis√©e ! Utilisez /lg start pour commencer une nouvelle partie.");
        plugin.getScoreboardManager().updateScoreboard();
    }

    private void setupGameEnvironment() {
        // Configurer l'environnement de jeu
        for (Player player : Bukkit.getOnlinePlayers()) {
            player.setHealth(20.0);
            player.setFoodLevel(20);
            player.setSaturation(20);
            player.getInventory().clear();
        }
    }

    private void teleportPlayersToGame() {
        // T√©l√©porter tous les joueurs au spawn configur√©
        Location gameLocation = plugin.getConfigManager().getSpawnLocation();

        if (gameLocation == null) {
            plugin.getLogger().warning("‚ö†Ô∏è Impossible de r√©cup√©rer le spawn configur√©, utilisation du spawn par d√©faut");
            World world = Bukkit.getWorld(plugin.getConfigManager().getSpawnWorld());
            if (world == null) {
                world = Bukkit.getWorlds().get(0);
            }
            gameLocation = world.getSpawnLocation();
        }

        for (Player player : Bukkit.getOnlinePlayers()) {
            player.teleport(gameLocation);
            player.setGameMode(GameMode.ADVENTURE);
        }

        plugin.getLogger().info("Joueurs t√©l√©port√©s au spawn: " + gameLocation.getWorld().getName() +
                " (" + gameLocation.getBlockX() + ", " + gameLocation.getBlockY() + ", " + gameLocation.getBlockZ() + ")");
    }

    private void showGameStatus() {
        broadcastMessage("¬ßaüë• Joueurs vivants : " + getAlivePlayersCount());
        showAlivePlayers();

        // Statistiques des √©quipes
        int werewolves = 0, villagers = 0;
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (isPlayerAlive(player)) {
                PlayerRole role = players.get(player.getUniqueId());
                if (role == PlayerRole.WEREWOLF) {
                    werewolves++;
                } else if (role != null) {
                    villagers++;
                }
            }
        }

        broadcastMessage("¬ßcüê∫ Loups restants : " + werewolves + " ¬ß7| ¬ßaüë• Village : " + villagers);
    }

    // M√©thodes utilitaires
    private void broadcastMessage(String message) {
        Bukkit.broadcastMessage(plugin.getConfigManager().getMessagePrefix() + " " + message);
    }

    public boolean isPlayerAlive(Player player) {
        return player != null && player.isOnline() &&
                player.getGameMode() != GameMode.SPECTATOR &&
                players.containsKey(player.getUniqueId());
    }

    public int getAlivePlayersCount() {
        int count = 0;
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (isPlayerAlive(player)) {
                count++;
            }
        }
        return count;
    }

    private void showAlivePlayers() {
        showAlivePlayers(null);
    }

    private void showAlivePlayers(Player target) {
        StringBuilder alive = new StringBuilder("¬ßaüë• Joueurs vivants : ");
        boolean first = true;
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (isPlayerAlive(player)) {
                if (!first) alive.append("¬ßf, ");
                alive.append("¬ße").append(player.getName());
                first = false;
            }
        }

        if (target != null) {
            target.sendMessage(alive.toString());
        } else {
            broadcastMessage(alive.toString());
        }
    }

    private void showAliveVillagers(Player werewolf) {
        werewolf.sendMessage("¬ßcüéØ Cibles possibles :");
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (isPlayerAlive(player) && players.get(player.getUniqueId()) != PlayerRole.WEREWOLF) {
                werewolf.sendMessage("¬ße- " + player.getName());
            }
        }
    }

    // M√©thodes pour g√©rer les actions sp√©ciales des r√¥les
    public void setProtectedPlayer(UUID playerId) {
        this.protectedPlayer = playerId;
    }

    public void setWitchHealTarget(UUID playerId) {
        this.witchHealTarget = playerId;
    }

    public void setWitchPoisonTarget(UUID playerId) {
        this.witchPoisonTarget = playerId;
    }

    public void setWitchUsedHealPotion(Player witch) {
        witchHealUsed.put(witch.getUniqueId(), true);
    }

    public void setWitchUsedPoisonPotion(Player witch) {
        witchPoisonUsed.put(witch.getUniqueId(), true);
    }

    public void setGuardProtectedHimself(Player guard) {
        guardSelfProtected.put(guard.getUniqueId(), true);
    }

    public void setSeerUsedPower(Player seer) {
        seerUsedPower.put(seer.getUniqueId(), true);
    }

    public void setGuardUsedPower(Player guard) {
        guardUsedPower.put(guard.getUniqueId(), true);
    }

    public boolean hasWitchUsedHealPotion(Player witch) {
        return witchHealUsed.getOrDefault(witch.getUniqueId(), false);
    }

    public boolean hasWitchUsedPoisonPotion(Player witch) {
        return witchPoisonUsed.getOrDefault(witch.getUniqueId(), false);
    }

    public boolean hasGuardProtectedHimself(Player guard) {
        return guardSelfProtected.getOrDefault(guard.getUniqueId(), false);
    }

    public boolean hasSeerUsedPower(Player seer) {
        return seerUsedPower.getOrDefault(seer.getUniqueId(), false);
    }

    public boolean hasGuardUsedPower(Player guard) {
        return guardUsedPower.getOrDefault(guard.getUniqueId(), false);
    }

    public void checkWinConditionsAfterLeave() {
        if (isGameRunning()) {
            checkWinConditions();
        }
    }

    public boolean addVote(UUID voter, UUID target) {
        if (!isPlayerAlive(Bukkit.getPlayer(voter)) || !isPlayerAlive(Bukkit.getPlayer(target))) {
            return false;
        }
        votes.put(voter, target);
        return true;
    }

    // Getters
    public GameState getCurrentState() {
        return currentState;
    }

    public boolean isGameRunning() {
        return currentState != GameState.WAITING && currentState != GameState.FINISHED;
    }

    public Map<UUID, PlayerRole> getPlayers() {
        return new HashMap<>(players);
    }

    public int getDayNumber() {
        return dayNumber;
    }

    /**
     * Change le temps uniquement pour les joueurs en partie
     */
    private void setTimeForPlayers(long time) {
        for (Player player : Bukkit.getOnlinePlayers()) {
            if (players.containsKey(player.getUniqueId())) {
                player.setPlayerTime(time, false);
            }
        }
    }
}